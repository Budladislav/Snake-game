<!DOCTYPE html>
<html>
<head>
  <title>Snake game imrpoved</title>
   <!-- <link rel="shortcut icon" href="fav.ico" type="image/x-icon"> -->
  <meta charset="utf-8">
  <!-- set actually width for mobile -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- forbid of screen expansion on mobile devices -->
  <meta name="viewport" content="user-scalable=no">
  <!-- <link rel="stylesheet" type="text/css" href="style.css"> -->
  <!-- <script type="text/javascript" src="jquery-3.3.1.min.js"></script> -->
  <script type="text/javascript"
    src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
  <style type="text/css">

    /*disable text selection*/
    * { 
      -moz-user-select: none; /* Firefox */
      -ms-user-select: none; /* Internet Explorer */
      -khtml-user-select: none; /* KHTML browsers (e.g. Konqueror) */
      -webkit-user-select: none; /* Chrome, Safari, and Opera */
      -webkit-touch-callout: none; /* Disable Android and iOS callouts*/
    }

    html,body{
      margin: 0;
      height: 100%;
    }

    /* js: minimal min-width 500/min-height 500.
      If client size bigger - size of body almost all of client */
    body{
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: Verdana;
      font-size: 1em;
      /*default, if js don't work*/
      min-width: 500px; 
      min-height: 500px;
      /* min-width, min-height - set when the window is opened/reloaded */
    }

    /* js: minmal width 500/height 500. If body bigger - size almost all of body*/
    #main-container {
      display: flex;
      flex-flow: column;
      /*default, if js don't work*/
      width: 500px;
      height: 500px;
      /* width, height - set when the window is opened/reloaded */
    }
    h1 {
      margin: 0;
      /*text-align: center;*/
    }
    p {
      margin: 0;
      /*text-align: center;*/
    }

    .header{
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 30px;
      padding: 5px;
      flex: 0 1 auto;
      border: 1px solid grey;
      border-radius: 20px 20px 0px 0px;
      position: relative; /*for img absolute position relatively .header*/
    }

    .header img{
      position: absolute;
      right: 0;
      top: 0;
      margin: 5px;
      cursor: pointer;
    }
    
    /*flex - occupies x2 free space except .header and .footer */
    #game-container{
      flex: 3 1 auto;
      display: flex;
      flex-direction: column;
    }

    /* flex: height - depends on content of #info-container */
    #info-bar{
      flex: 0 1 auto;
      display: flex;
      /*flex-flow: row;*/
      justify-content: space-around;
      align-items: center;
      border: 1px solid grey;
      padding: 5px 0;
    }
    #info-bar p {
      display: inline-block;
    }

    #canvas-container{
      flex: 1 1 auto;
      display: flex;
      justify-content: center;
      align-items: center; 
      border: 1px solid grey;
    }
    
    canvas{
      border: 5px solid blue;
    }
    
    /*flex - occupies x1 free space except .header and .footer */
    #mobile-control-container{
      display: flex;
      flex: 1 1 auto;
      border: 1px solid grey;
      box-sizing: border-box;
      /* width, height - set in js when the window is opened/reloaded */
    }
    
    #controls-speed-container{
      display: flex;
      flex-direction: column;
      flex: 1 1 auto;
      justify-content: space-around;
      align-items: center;
      border-right: 1px solid black;
    }

    #controls-direction-container{
      display: flex;
      flex-flow: column;
      flex: 2 1 auto;
      justify-content: center;
    }
/*    #controls-direction{
      display: flex;
      justify-content: space-around;
    }*/
    #controls-direction-up, #controls-direction-down{
      display: flex;
      flex: 1 1 content;
      justify-content: center;
    }
    #controls-direction-leftright{
      display: flex;
      flex: 3 1 content;
      justify-content: space-around;
    }



    .span-big{
      font-size: 1.5em;
    }
    .footer { /* flex: height - depends on content of .footer */
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 0 1 auto;
      padding: 5px 0;
      border: 1px solid grey;
      border-radius: 0px 0px 20px 20px;
      box-sizing: border-box;
    }
    .footer a {
      color: black;
      text-decoration: none;
      border-bottom: 1px solid black;
    }
    
    .footer a:hover {
      border: 1px solid black;
      padding: 1px;
    }
    
    .footer a:active {
      background: orange;
      border-radius: 10px;
      padding: 2px;
      border: 1px solid black;
    }

    .mobile-control-button{
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: lightblue;
      border-radius: 50%;
      box-shadow:
        inset rgba(0,0,0,.5) -3px -3px 8px,
        inset rgba(255,255,255,.9) 3px 3px 8px,
        rgba(0,0,0,.8) 3px 3px 8px -3px;
      /*default, if js don't work*/
      width: 50px;
      height: 50px;
      /*width,height,margin - js */
    }

    .info-window{
      position: absolute;
      display: flex;
      flex-flow: column;
      align-items: center;
      justify-content: space-around;
      border: 1px solid black;
      border-radius: 20px;
      background-color: rgba(255,255,255,0.9);
      width: 300px;
      height: 125px;
      padding: 20px 10px 10px 10px;
    }

    #controls-window{
      height: 300px;
      display: none;
    }
    #gameover-window{
      display: none;
    }
    #pause-window{
      display: none;
    }
    .window-button{
      box-shadow:
        inset rgba(0,0,0,.5) -3px -3px 8px,
        inset rgba(255,255,255,.9) 3px 3px 8px,
        rgba(0,0,0,.8) 3px 3px 8px -3px;
      color: white;
    }
    .close-btn{
      border: 1px solid grey;
      padding: 5px;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      justify-content: center;
      cursor: pointer;
      font-weight: bold;
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: gray;
      
    }
    .ok_btn{
      width: 30%;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid grey;
      cursor: pointer;
      background-color: gray;
      font-weight: bold;
      text-align: center;
    }
    
    .div-text p {
      margin-bottom: 5px;
    }

  </style>
</head>
<body>
<!-- info windows -->
    <div id="gameover-window" class="info-window">
      <div class="close-btn window-button"><p>×</p></div>
      <h1>Game over</h1>
      <p id="over-score"></p>
      <p id="to-record"></p>
      <div class="ok_btn window-button"><p>OK</p></div>
    </div>

    <div id="controls-window" class="info-window">
      <div class="close-btn window-button"><p>×</p></div>
      <h1><b id="constols_state">Paused</b></h1>
      <h1><b>Control buttons:</b></h1>
        <div class="div-text">
          <p>
            <b>↑,←,↓,→</b> or <b>W,A,S,D</b> - <i>direction</i>
          </p>
          <p> <b>P</b> - <i>Pause/unpause</i></p>
          <p> <b>I</b> - <i>PC controls info show/hide</i></p>
          <p> <b>N</b> - <i>Speed decrease</i></p>
          <p> <b>M</b> - <i>Speed increase</i></p>
          <p> <b>Esc/Enter</b> - <i>Close window</i></p>
        </div>
      <div class="ok_btn window-button"><p>ok</p></div>
    </div>

    <div id="pause-window" class="info-window">
      <div class="close-btn window-button"><p>×</p></div>
      <h1>Game paused</h1>
      <div class="ok_btn window-button"><p>Resume</p></div>
    </div>
<!-- info windows end -->

<!-- #main-container -->
  <div id="main-container">

    <div class="header">
      <img id="help" src="media/question_mark.png" alt="controls info" height="30px">
      <h1>Snake</h1>
    </div>

    <div id="game-container">
      <div id="info-bar">
          <p>Score: <b><span id="s_score">0</span></b></p>
          <p>Record: <b><span id="s_record"></span></b></p>
          <p>Speed: <b><span id="s_speed"></span></b></p>
      </div>
      
      

      <div id="canvas-container">
        <div id="controls-speed-container-landscape-placeholder"></div>
        <canvas id="canvas"></canvas> <!-- width and height are set in js -->
        <div id="controls-direction-container-landscape-placeholder"></div>
      </div>

      

    </div>


    <div id="mobile-control-container"> <!-- displays only for touchscreen devices --> 

      <!-- <div id="copy-block1"> -->

        <div id="controls-speed-container">
          <div class="mobile-control-button" id="button-speed_up"><span class="span-big">+</span></div>
          <div class="mobile-control-button" id="button-speed_down"><span class="span-big">-</span></div>
        </div>

      <!-- </div> -->

      <!-- <div id="copy-block2"> -->
      
        <div id="controls-direction-container">
  
          <div id="controls-direction-up">
            <div class="mobile-control-button" id="button-up"> <span class="span-big">▲</span> </div>
          </div>
  
          <div id="controls-direction-leftright">
            <div class="mobile-control-button" id="button-left"> <span class="span-big">◄</span></div>
            <div class="mobile-control-button" id="button-right"> <span class="span-big">►</span></div>
          </div>
  
          <div id="controls-direction-down">
            <div class="mobile-control-button" id="button-down"> <span class="span-big">▼</span></div> 
          </div> 
        
        </div>

      <!-- </div> -->

    </div>


    <div class="footer">
      <p>by <a href="http://www.budladislav.info/">Budladislav</a> jan.2019</p>
    </div>

  </div>
<!-- #main-container end -->

  <script type="text/javascript">
    'use strict';

    /* GLOBAL VARIABLES */

    let e_Canvas = document.getElementById('canvas');
    let canvasContext = e_Canvas.getContext('2d');

    //values assigned in fInterfaceAndGlobalVariablesSetup()
    let n_BlockSize;
    let n_CanvasWidth; 
    let n_CanvasHeight;
    let n_WidthInBlocks; // 0,0 - top-left cell
    let n_HeightInBlocks; //n_WidthInBlocks-1, n_HeightInBlocks-1 - bottom-right cell
    //values assigned in fInterfaceAndGlobalVariablesSetup()

    let n_updateFrequancyMs;
    let n_SpeedMode;
    let s_GameState = 'active'; // active, paused or over

    let n_Score = 0;
    let n_TimeoutId; //for game loop
    let n_IntervalId; //for repeating action while keypress 

    let o_Directions = {
      37: 'left', //←
      65: 'left', //A
      38: 'up', //↑
      87: 'up', //W
      39: 'right', // →
      68: 'right', //D
      40: 'down', //↓
      83: 'down' //S
    }

    /* GLOBAL VARIABLES end */

    /* FUNCTIONS */

    /*setup intrface. Used for dynamic setting sizes of elements.
    min-width 500px, min-height 500px. if client size fewer - scrollbars
    if bigger - content size expands to client size*/
    let  fInterfaceAndGlobalVariablesSetup = () => {
      let nWindowWidth = document.documentElement.clientWidth;
      let nWindowHeight = document.documentElement.clientHeight;
      let nWindowShortSide = Math.min(nWindowWidth,nWindowHeight);
      let nBodyMinWidth;
      let nBodyMinHeight;
      let nBodyMinSide;
  
      if (nWindowWidth < 500){
        nBodyMinWidth = 500;
      } else {
        nBodyMinWidth = nWindowWidth - 20;
      }
      if (nWindowHeight < 500){
        nBodyMinHeight = 500;
      } else {
        nBodyMinHeight = nWindowHeight - 20;
      }

      nBodyMinSide = Math.min(nBodyMinWidth,nBodyMinHeight);
  
      $('body').css({
        'min-width' : nBodyMinWidth + 'px',
        'min-height' : nBodyMinHeight + 'px'
      });
      $('#main-container').css({
        'width' : nBodyMinWidth + 'px',
        'height' : nBodyMinHeight + 'px'
      });
  
      if (!fIsMobile()) { //desctop
        $('#mobile-control-container').css('display','none');
        //speed
        n_updateFrequancyMs = 85;
        n_SpeedMode = 20 - n_updateFrequancyMs / 5;
      } else { //mobile
        $('#help').css('display','none');
        //Increases text size on mobile devices
        (nWindowWidth < nWindowHeight)
          ? $('body').css('font-size','2em')
          : $('body').css('font-size','1.5em')    
        
        let nControlContainerHeight = (nWindowWidth < nWindowHeight)
          ? nWindowShortSide * 0.5 : nWindowShortSide * 0.25;
        $('#mobile-control-container').css({
          'width' : nBodyMinWidth + 'px',
          'height' : nControlContainerHeight + 'px'
        });


        //$('#mobile-control-container').сss('flex','0.5 1 auto')
  
        let nButtonSize = (nControlContainerHeight - 20) / 3 ;
        $('.mobile-control-button').css({
          'width': nButtonSize +'px',
          'height': nButtonSize +'px',
          'margin': '10px'
        });

        //speed
        n_updateFrequancyMs = 135;
        n_SpeedMode = 30 - n_updateFrequancyMs / 5;

        $('.info-window').css('height',nWindowHeight / 6);
        $('.info-window').css('width', nWindowWidth / 2);

        $('.close-btn').css('height', '40px');
        $('.close-btn').css('width', '40px');

        //landscape orientation
        if (nWindowWidth > nWindowHeight){
          $('.header').css('display','none');
          $('#info-bar').css('border-radius','20px 20px 0px 0px');
          $('.info-window').css('height',nWindowHeight / 2.5);
          $('.info-window').css('width', nWindowWidth / 2.5);
          $('.close-btn').css('height', '30px');
          $('.close-btn').css('width', '30px');

          //move controlls
          // $("#copy-block1").appendTo("#controls-speed-container-landscape-placeholder");
          // $("#copy-block2").appendTo("#controls-direction-container-landscape-placeholder");

          // $('#mobile-control-container').remove();

        }

      } //mobile end


      if (localStorage['lsSnakeRecord'] === undefined){
        localStorage['lsSnakeRecord'] = '0';
      }
      $('#s_record').text(localStorage['lsSnakeRecord']);
      $('#s_speed').text(n_SpeedMode);

      n_BlockSize = Math.floor( (nBodyMinSide / 20) / 10) * 10;
  
      n_CanvasWidth = Math.floor( $('#canvas-container').width() / n_BlockSize) * n_BlockSize;
      n_CanvasHeight = Math.floor( $('#canvas-container').height() / n_BlockSize) * n_BlockSize;

      //css canvas width and heights will be equal to html attr-s
      e_Canvas.width = n_CanvasWidth;
      e_Canvas.height = n_CanvasHeight;

      //for mobile
      n_CanvasHeight = Math.floor( $('#canvas-container').height() / n_BlockSize) * n_BlockSize;
      e_Canvas.height = n_CanvasHeight;
      //for mobile

      n_WidthInBlocks = Math.floor(n_CanvasWidth / n_BlockSize);
      n_HeightInBlocks = Math.floor(n_CanvasHeight / n_BlockSize); 
    }
  
    //check is it device mobile (with touchscreen). True - mobile/ false - desctop
    let fIsMobile = () => {
      return ('ontouchstart' in document.documentElement);
    }

    let fDrawGrid = () => {
      canvasContext.strokeStyle = "silver";
      canvasContext.lineWidth = 1;
      canvasContext.beginPath();
      //horizontal  lines
      for (var i = n_HeightInBlocks - 1; i >= 0; i--) {
        canvasContext.moveTo(0, i * n_BlockSize);
        canvasContext.lineTo(n_CanvasWidth,i * n_BlockSize); 
      }
      //vertical lines
      for (var i = n_WidthInBlocks - 1; i >= 0; i--) {
        canvasContext.moveTo(i * n_BlockSize, 0);
        canvasContext.lineTo(i * n_BlockSize, n_CanvasHeight); 
      }
      canvasContext.stroke();
    }

    //Game stops (clear interval of setInterval() ), and draw mesage "End game"
    let fGameOver = () => {
      $('#over-score').text('Score: ' + n_Score);
      //record check
      if (+localStorage['lsSnakeRecord'] > n_Score){
        $('#to-record').text(+localStorage['lsSnakeRecord'] - n_Score + ' points till record');
      } else if (+localStorage['lsSnakeRecord'] === n_Score) {
        $('#to-record').text('Wow, almost record!');
      } else if (+localStorage['lsSnakeRecord'] < n_Score) {
        localStorage['lsSnakeRecord'] = n_Score;
        $('#to-record').text('New record! ' + n_Score + ', Well done!');
        $('#over-score').css('display','none');
      } 

      hGameoverWindowOpen();
    }

    let fGameLoop = () => {
      canvasContext.clearRect(0,0,n_CanvasWidth,n_CanvasHeight);
      // fDrawGrid(); //for debug
      // drawCheck(n_WidthInBlocks-1,n_HeightInBlocks-1); //for debug

      o_Apple.draw();
      o_Snake.move();
      o_Snake.draw();
      if (s_GameState === 'over'){
        return;
      }
      n_TimeoutId = setTimeout(fGameLoop, n_updateFrequancyMs);
    }

    let fGamePause = () => {
      clearTimeout(n_TimeoutId);
      s_GameState = 'paused';
    }

    let fGameStop = () => {
      clearTimeout(n_TimeoutId);
      s_GameState = 'over';
    }

    let fGameContinue = () => {
      fGameLoop();
      s_GameState = 'active';
    }

    //hide info-window and resume game, or reload game if it's over
    let fCloseAllWindows = () => {
      if (s_GameState === 'paused'){
        $('#controls-window').css('display','none');
        $('#pause-window').css('display','none');
        $('#gameover-window').css('display','none');
        s_GameState = 'active';
        fGameContinue();
      } else if (s_GameState === 'over'){
        location.reload(false);
      }   
    }

    let fDrawCircle = (Xcenter, Ycenter, radius, fill = true, style = 'black') => {
      canvasContext.fillStyle = style;
      canvasContext.beginPath();
      canvasContext.arc(Xcenter, Ycenter, radius, 0, Math.PI * 2);
      (fill) ? canvasContext.fill() : canvasContext.stroke();
    }
    

    /* FUNCTIONS end */

    /* CONSTRUCTORS */

    //game cell. Can be empty, Apple or snake part
    let Block = function(col, row) {
      this.col = col;
      this.row = row;
    }

    let Snake = function() {
      this.segments = [
        new Block(Math.floor(n_WidthInBlocks / 2) + 1, Math.floor(n_HeightInBlocks / 2)),
        new Block(Math.floor(n_WidthInBlocks / 2), Math.floor(n_HeightInBlocks / 2)),
        new Block(Math.floor(n_WidthInBlocks / 2) - 1, Math.floor(n_HeightInBlocks / 2))
      ];

      this.direction = 'right';
      this.nextDirection = 'right';
    }

    let Apple = function() {
      this.move();
    }

    /* CONSTRUCTORS end */

    /* PROTOTYPE METHODS */

    Block.prototype.drawSnakePart = function(color = 'black') {
      let x = this.col * n_BlockSize;
      let y = this.row * n_BlockSize;
      canvasContext.fillStyle = color;
      canvasContext.fillRect(x, y, n_BlockSize, n_BlockSize);
    }

    Block.prototype.drawSnakeHead = function(color = 'black') {
      canvasContext.fillStyle = color;
      let TopLeftX = this.col * n_BlockSize;
      let TopLeftY = this.row * n_BlockSize;
      let radius = n_BlockSize / 2;
      let Xcenter = this.col * n_BlockSize + radius;
      let Ycenter = this.row * n_BlockSize + radius;

      fDrawCircle(Xcenter, Ycenter, radius); //black circle

      //suitable half square + suitable eyes
      switch (o_Snake.direction) {
        case 'up':
          canvasContext.fillRect(TopLeftX, TopLeftY + radius, n_BlockSize, radius);
          fDrawCircle(Xcenter + n_BlockSize / 6, Ycenter - n_BlockSize / 10, radius / 6, true, 'white');
          fDrawCircle(Xcenter - n_BlockSize / 6, Ycenter - n_BlockSize / 10, radius / 6, true, 'white');
          break;
        case 'right':
          canvasContext.fillRect(TopLeftX, TopLeftY, radius, n_BlockSize);
          fDrawCircle(Xcenter + n_BlockSize / 10, Ycenter - n_BlockSize / 6, radius / 6, true, 'white');
          fDrawCircle(Xcenter + n_BlockSize / 10, Ycenter + n_BlockSize / 6, radius / 6, true, 'white');
          break;
        case 'down':
          canvasContext.fillRect(TopLeftX, TopLeftY, n_BlockSize, radius);
          fDrawCircle(Xcenter + n_BlockSize / 6, Ycenter + n_BlockSize / 10, radius / 6, true, 'white');
          fDrawCircle(Xcenter - n_BlockSize / 6, Ycenter + n_BlockSize / 10, radius / 6, true, 'white');
          break;
        case 'left':
          canvasContext.fillRect(TopLeftX + radius, TopLeftY, radius, n_BlockSize);
          fDrawCircle(Xcenter - n_BlockSize / 10, Ycenter - n_BlockSize / 6, radius / 6, true, 'white');
          fDrawCircle(Xcenter - n_BlockSize / 10, Ycenter + n_BlockSize / 6, radius / 6, true, 'white');
          break;
      }

      
    }

    // Block.prototype.drawSnakeTeal = function(color = 'black') {
    //   canvasContext.fillStyle = color;

    //   let TopLeftX = this.col * n_BlockSize;
    //   let TopLeftY = this.row * n_BlockSize;
    //   let radius = n_BlockSize / 2;
    //   let Xcenter = this.col * n_BlockSize + radius;
    //   let Ycenter = this.row * n_BlockSize + radius;

    //   //suitable triangle
    //   switch (o_Snake.direction) {
    //     case 'up':
    //       canvasContext.fillRect(TopLeftX, TopLeftY + radius, n_BlockSize, radius);
    //       break;
    //     case 'right':
    //       canvasContext.fillRect(TopLeftX, TopLeftY, radius, n_BlockSize);
    //       break;
    //     case 'down':
    //       canvasContext.fillRect(TopLeftX, TopLeftY, n_BlockSize, radius);
    //       break;
    //     case 'left':
    //       canvasContext.beginPath();
    //       canvasContext.moveTo(TopLeftX, TopLeftY);
    //       canvasContext.lineTo(TopLeftX, TopLeftY  + n_BlockSize);
    //       canvasContext.lineTo(TopLeftX + n_BlockSize, TopLeftY  + radius);
    //       canvasContext.lineTo(TopLeftX, TopLeftY);
    //       canvasContext.fill();
    //       break;
    //   }
    // }

    Block.prototype.drawApple = function() {
      let radius = n_BlockSize / 2;
      let Xcenter = (this.col * n_BlockSize) + radius;
      let Ycenter = (this.row * n_BlockSize) + radius;

      canvasContext.fillStyle = 'tomato';
      canvasContext.strokeStyle = 'black';
      canvasContext.lineWidth = 2;
      
      fDrawCircle(Xcenter, Ycenter, radius, true, 'tomato');
      fDrawCircle(Xcenter, Ycenter, radius-1, false);
    }

    //check equality positions of 2 blocks
    Block.prototype.equal = function(otherBlock) {
      return this.col === otherBlock.col && this.row === otherBlock.row;
    }

    //draw square for each part of snake
    Snake.prototype.draw = function(direction) {
      //head
      this.segments[0].drawSnakeHead();

      //body
      for (let i = 1; i < this.segments.length; i++){
        this.segments[i].drawSnakePart();
      }

      //teal
      // this.segments[this.segments.length - 1].drawSnakeTeal();
    }

    //Create new head and add it to start of snake, to move it on the direction
    Snake.prototype.move = function() {
      let o_Head = this.segments[0];
      let o_NewHead;

      this.direction = this.nextDirection;

      if (this.direction === 'right'){
        o_NewHead = new Block(o_Head.col + 1, o_Head.row);
      } else if (this.direction === 'left'){
        o_NewHead = new Block(o_Head.col - 1, o_Head.row);
      } else if (this.direction === 'up'){
        o_NewHead = new Block(o_Head.col, o_Head.row - 1);
      } else if (this.direction === 'down'){
        o_NewHead = new Block(o_Head.col, o_Head.row + 1);
      }

      if (this.fCheckCollision(o_NewHead) ){
        fGameOver();
        return;
      }

      this.segments.unshift(o_NewHead);

      if (o_NewHead.equal(o_Apple.position) ){
        $('#s_score').text(++n_Score);

        if (+localStorage['lsSnakeRecord'] < n_Score){
          $('#s_record').text(n_Score + ' new!');
        }

        o_Apple.move();
      } else {
        this.segments.pop();
      }
    }

    //check collision of snake head with own body or wall
    Snake.prototype.fCheckCollision = function(headBlock){
      //check wall collision
      let b_TopCollision = (headBlock.row === -1);
      let b_RightCollision = (headBlock.col === n_WidthInBlocks);
      let b_BottomCollision = (headBlock.row === n_HeightInBlocks);
      let b_LeftCollision = (headBlock.col === -1);
      let b_WallCollision = b_TopCollision || b_RightCollision ||
        b_BottomCollision || b_LeftCollision;
      //check self collision
      let b_SelfColission = false;
      for (let i = 0; i < this.segments.length; i++){
        if (headBlock.equal(this.segments[i]) ){
          b_SelfColission = true;
          break;
        }
      }

      return b_WallCollision || b_SelfColission;
    }

    //Setting next direction, based on pressed key
    Snake.prototype.setDirection = function(s_NewDirection){
      if (this.direction === 'up' && s_NewDirection === 'down'){
        return;
      } else if (this.direction === 'right' && s_NewDirection === 'left'){
        return;
      } else if (this.direction === 'down' && s_NewDirection === 'up'){
        return;
      } else if (this.direction === 'left' && s_NewDirection === 'right'){
        return;
      }
      this.nextDirection = s_NewDirection;
    }

    Apple.prototype.draw = function(){
      this.position.drawApple();
    }

    //Move apple in random position except snake
    Apple.prototype.move = function(){
      let randomCol;
      let randomRow;
      let bSnakePosition;

      do {
        bSnakePosition = false;
        randomCol = Math.floor(Math.random() * (n_WidthInBlocks));
        randomRow = Math.floor(Math.random() * (n_HeightInBlocks));
        this.position = new Block(randomCol, randomRow);
        for (var i = o_Snake.segments.length - 1; i >= 0; i--) { //check snake position
          if (this.position.equal(o_Snake.segments[i]) ){
            bSnakePosition = true; //new apple position is on snake
          }
        }
      } while (bSnakePosition);
      
    }

    /* PROTOTYPE METHODS */

    /* EVENT HANDLERS */

    //press on 'I' button (code 73) or button in header
    //displays #controls-window or close it
    let fShowHideControllsInfo = () => {
      if (s_GameState === 'active'){
        fGamePause();
        $('#controls-window').css('display','flex');
        return;
      } else if (s_GameState === 'over'){
        $('#constols_state').text('Game over');
        $('#gameover-window').css('display','none');
        $('#controls-window').css('display','flex');
      } else if (s_GameState === 'paused'){
        if ($('#pause-window').css('display') === 'flex'){ //paused with P
          $('#pause-window').css('display','none')
          $('#controls-window').css('display','flex');
          return;
        } else {
          $('#controls-window').css('display','none');
          fGameContinue();
        }
      }
    }

    //displays #gameover-window and stop game
    let hGameoverWindowOpen = () => {
      fGameStop();
      $('#gameover-window').css('display','flex');
    }


    /* EVENT HANDLERS end */
    let fHandleUsedKeys = (action) => {
      switch (action){
        case 'pause':
          fPauseUnpause();
          break;
        case 'info':
          fShowHideControllsInfo();
          break;
        case 'speed-':
          fSpeedDecrease();
          break;
        case 'speed+':
          fSpeedIncrease();
          break;
        case 'closeWindow':
          fCloseAllWindows();
          break;
      }
    }

    //press on 'P' button (code 80) - pause and unpause game
    let fPauseUnpause = () => {
      if (s_GameState === 'over'){
        return;
      }
      if ($('#controls-window').css('display') === 'flex'){
        $('#controls-window').css('display','none');
        fGameContinue();
        return;
      }
      if (s_GameState === 'active'){
        fGamePause();
        $('#pause-window').css('display','flex');
      } else{
        fGameContinue();
        $('#pause-window').css('display','none');
      } 
    }

    //press on N (78) - decrease speed
    let fSpeedDecrease = () => {
      if (fIsMobile()){ //moile speed
        if (n_updateFrequancyMs < 145){
          n_updateFrequancyMs += 5;
          n_SpeedMode = 30 - n_updateFrequancyMs / 5;
        }
      } else { //desctop speed
        if (n_updateFrequancyMs < 95){
          n_updateFrequancyMs += 5;
          n_SpeedMode = 20 - n_updateFrequancyMs / 5;
        }
      }

      if (n_SpeedMode === 1){
        $('#s_speed').text(n_SpeedMode + ' (min)');
      } else{
        $('#s_speed').text(n_SpeedMode);
      }
    }

    //press on M (77) - increase speed
    let fSpeedIncrease = () => {
      if (fIsMobile()){ //moile speed
        if (n_updateFrequancyMs > 100){
          n_updateFrequancyMs -= 5;
          n_SpeedMode = 30 - n_updateFrequancyMs / 5;
        }
      } else { //desctop speed
        if (n_updateFrequancyMs > 50){
          n_updateFrequancyMs -= 5;
          n_SpeedMode = 20 - n_updateFrequancyMs / 5;
        }
      }

      if (n_SpeedMode === 10){
        $('#s_speed').text(n_SpeedMode + ' (max)');
      } else{
        $('#s_speed').text(n_SpeedMode);
      }

    }

    /* EVENTS */

    //buttons ok, resume and × in additional windows 
    $('.window-button').click(fCloseAllWindows);

    //click on ? in hedaer of desctop vesion. Same as press I
    $('#help').click(fShowHideControllsInfo);

    //Common event for keydown
    $("body").keydown((e)=>{
      // console.log(e.keyCode);
      if (s_GameState === 'over'){
        if (e.keyCode === 27 || e.keyCode === 13){
          fCloseAllWindows();
        } else if (e.keyCode === 73){
          fShowHideControllsInfo();
          return;
        }
      }

      //direction
      let s_NewDirection = o_Directions[e.keyCode];
      if (s_NewDirection !== undefined) {
        o_Snake.setDirection(s_NewDirection);
      }

      //other keys
      let o_UsedKeys = {
        80: 'pause', //P
        73: 'info', //I
        78: 'speed-', //N
        77: 'speed+', //M
        13: 'closeWindow', //Enter
        27: 'closeWindow' //Esc
      }

      let s_Action = o_UsedKeys[e.keyCode];
      fHandleUsedKeys(s_Action);

    });

    //Mobile events
    //handles taps at mobile control buttons (and their childs) 
    $('.mobile-control-button').on('touchstart',(event)=>{
      //forbid to fire handler if any contol button still in use
      if (event.touches.length > 1) {
        return;
      }
      
      let a_ButtonsIds = ['button-speed_up', 'button-speed_down',
        'button-up', 'button-left', 'button-down', 'button-right'];
      let a_ButtonsActions = ['speed+', 'speed-', 'up', 'left',
        'down', 'right'];

      for (var i = a_ButtonsIds.length - 1; i >= 0; i--) {

        if (event.currentTarget.id ===  a_ButtonsIds[i]){
          //speed
          if (i < 2){
            fHandleUsedKeys(a_ButtonsActions[i]);
          } else { //direction
            o_Snake.setDirection(a_ButtonsActions[i]);
          }
          break;
          // b_DirectionKeyHold = (a_ButtonsActions[i] === 'up'
          // || a_ButtonsActions[i] === 'right' || a_ButtonsActions[i] === 'down'
          // || a_ButtonsActions[i] === 'left');
          // setAction(a_ButtonsActions[i]);
          // n_pressIntervalId = setInterval(()=>{ball.setAction(a_ButtonsActions[i]);},25);
          
        }
      }
    });

    /* EVENTS end */

    // let  drawCheck = function(col, row) {
    //   let x = col * n_BlockSize;
    //   let y = row * n_BlockSize;
    //   canvasContext.fillStyle = 'black';
    //   canvasContext.fillRect(x, y, n_BlockSize, n_BlockSize);
    // }

    /* MAIN CODE */
    fInterfaceAndGlobalVariablesSetup();
    let o_Snake = new Snake();
    let o_Apple = new Apple();
    fGameLoop();
    // localStorage.clear();

    /* MAIN CODE end */


  </script>

</body>
</html>